# Распознование текста из таблиц на загружаемых фотографиях
**Цель проекта**: подготовить рабочее решение, которое позволит извлекать из отсканированных или сфотографированных справок по форме 405 данные о донации крови, в частности:

- полную дату донации
- тип донации
- вид донации


**Основные этапы проекта:**

1. Детекция табличных данных
2. Предобработка фотографий
3. Детекция и распознование текста с таблиц

# Выводы

В ходе работы получилось рабочее решение, позволяющиее по загруженному фото получать медицинские данные в csv файле. Полное решение можно посмотреть в [тетрадке.](https://github.com/AnastasiaBatmanova/donor_search_ocr1/blob/master/detection-recognition-scan-foto-medicaldocs.ipynb)

**Для детекции были опробованы два подхода**:

- детекция таблиц методами opencv. Это хороший вариант решения, который позволил бы избежать использования в коде сложных продуктов, но у него выявилось несколько недостатков: он плохо обрабатывает фото с артефактами (например, печатями), что требует написания дополнительного кода и не работает с некачественными, размытыми фотографиями.
- детекция таблиц с помощью обученной нейронной сети FAST RCNN. Нейронная сеть хорошо находит таблицы, но у нее есть проблемы с границами на фото с искаженной перспективой и мятых листах. Эту проблему легко удалось решить с помощью расширения отступов от границ бокса.

**Для предобработки фотографий были опробованы следующие инструменты:**

- методы opencv включающие в себя повороты изображений, цветокоррекцию и выравнивание. Этот подход оказался очень эффективным.
- автоэнкодеры. В проекте не представлены из-за большого размера кода. Автоэнкодеры с латентным пространством не использовались, т.к. у нас недостаточно документов на русском языке, чтобы по ним можно было качественно обучить нейронную сеть. Поэтому использовалось прямое кодирование/декодирование изображений с помощью одного слоя свертки и пуллинга

**Распознавание текста**

- рассматривались  две библиотеки: pytesseract и easyocr. Одним из существенных минусов pytesseract является то, что модель очень плохо распознает текст на фотографиях с ненадлежащим качеством. Это критичный момент, т.к. у нас в выборке таких фото может быть много. Несомненным преимуществом easyocr перед другими моделями для распознавания еще и является то, что в нее встроены такие продвинутые алгоритмы детекции текста как CRAFT, что окончательно определило выбор в пользу этой библиотеки.

**В целом, не используя сложных инструментов, нам удалось достигнуть точности в 72%. Основная проблема заключается в том, что при искажении перспективы, размытии или деформации справки, EASYOCR начинает плохо считывать данные, что приводит у ухудшению результатов работы алгоритма. Следующим этапом для развития проекта может стать приведение фотографий в надлежащее качество с написанием собственных сетей на базе архитектур GAN и автоэнкодеров.**



# Микросервис для обработки медицинских справок

Репозиторий содержит сервис, который принимает изображения и выдаёт в ответ информацию об изображении.

## Cодержимое репозитория
- _requirements.txt_ - список python библиотек, необходимых для запуска сервиса. Чтобы установить необходимые пакеты, выполните команду
```
    pip install -r requirements.txt
```

- _src/app.py_ - основной скрипт репозитория, который запускает веб-сервер. Чтобы воспользоваться этим файлом, запустите его через вашу IDE (PyCharm, VSCode) или командную консоль.

- _src/model.py_ - файл содержит функцию _process_image_, которая принимает на вход путь до файла изображения, обрабатывает его и выдаёт ответ веб-серверу.

- _src/tmp_ - временная папка, куда будут сохраняться изображения, полученные сервисом.

  
## Как протестировать

1. Склонируйте репозиторий на локальный компьютер;
2. **В папку src необходимо поместить файл с FAST RCNN. Скачать его нужно по [ссылке](https://drive.google.com/file/d/1Sh4YzBAsY99B2w7-l3zPvMp7cB6aETOp/view?usp=sharing)**.
3. Перейдите в папку репозитория;
4. Установите необходимые пакеты (pip install -r requirements.txt);
5. Запустите скрипт _app.py_ в папке _src_.
6. В консоле запуска появится сообщение вида
```
INFO:     Started server process [59740]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
INFO:     Uvicorn running on http://0.0.0.0:8000 (Press CTRL+C to quit)
```
6. Перейдите по ссылкe в последней строке сообщения.
7. В поле выбора файла выберите любой локальный файл с вашего компьютера и нажмите кнопку "Submit Query".
8. Зайдите в папку _src/tmp_ и убедитесь, что загруженный вами файл появился в этой папке.

## Как это работает
1. После запуска скрипта _src/app.py_ на локальном компьютере запускается веб-сервер, который "слушает" входящие запросы на порту 8000.
2. Когда вы переходите по ссылке http://0.0.0.0:8000, то вы создаёте веб запрос, который обрабатывается запущенным сервером.
3. При обращении к странице с, запрос обрабатывается функцией _main_ из файла _app.py_, т.к. ваш запрос не содержит явного указания пути до требуемой веб-страницы. Эта функция возвращает вашему браузеру HTML код, который рисует форму загрузки изображения: поле выбора файла и кнопку "Submit Request". Прочитать подробнее можно [здесь](https://www.w3schools.com/html/html_forms.asp). 
4. После нажатия на кнопку "Submit Request" создаётся ещё один запрос к серверу, но теперь по адресу http://0.0.0.0:8000/ocr, который обрабатывается функцией _process_request_ из файла _app.py_. Содержимое загруженного файла передаётся в этом запросе в переменной _file_.
5. Загруженное изображение сохраняется в папку tmp.
6. Из файла _model.py_ вызывается функция _process_image(file)_, которая получает на вход путь к сохранённому файлу. 
7. Результат обработки изображения возвращается пользователю как ответ на его запрос.

## Docker container

Пример того, как упаковать сервис в Docker образ, показан в файле Dockerfile.

Для сборки образа необходимо выполнить команду
```
  docker build --tag ocr:0.1 .
```

Для запуска контейнера
```
  docker run --rm -d -p 8010:8000 --name ocr ocr:0.1
```
после выполнения этой команды сервис будет доступен на порту 8010

Для остановки запущенного контейнера
```
  docker stop ocr
```
 
